import { asn1_u8_decode } from './asn1_decode.jsy'
import { asn1_u8_encode } from './asn1_encode.jsy'
import { asn1_der_positive_int, compact_positive_int } from './asn1_positive_int.jsy'

export function encode_ecdsa_asn1({r, s}) ::
  return asn1_u8_encode @#
    0x30, // sequence
    @[] 0x02, asn1_der_positive_int(r) // integer r
    @[] 0x02, asn1_der_positive_int(s) // integer s

export function decode_ecdsa_asn1(ecdsa_asn1) ::
  const node = asn1_u8_decode @ ecdsa_asn1
  const [r_node, s_node] = node.parse_parts()
  return @{} r: r_node.content, s: s_node.content

const ecdsa_raw_len = @[]
  @[] 32, 30, 31, 32, 33
  @[] 48, 46, 47, 48, 49
  @[] 66, 63, 64, 65, 66

.reduce @
  (r, e) => ::
    for let i=1; i<e.length; i++ ::
      r[e[i]] = e[0]
    return r
  []

export function encode_ecdsa_raw({r, s}) ::
  const len_part = ecdsa_raw_len[r.byteLength]
  if ! len_part ::
    throw new Error @ `Invalid byteLength for ECDSA raw encoding`

  r = compact_positive_int(r, len_part)
  s = compact_positive_int(s, len_part)

  const u8 = new Uint8Array(len_part + len_part)
  u8.set @ r, len_part - r.byteLength
  u8.set @ s, len_part + len_part - s.byteLength
  return u8

export function decode_ecdsa_raw(ecdsa_raw) ::
  const u8 = new Uint8Array(ecdsa_raw.buffer || ecdsa_raw)
  const n = u8.byteLength >>> 1
  const r = u8.slice(0, n)
  const s = u8.slice(n,)
  return { r, s }


